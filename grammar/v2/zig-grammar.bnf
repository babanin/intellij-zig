{
  parserClass='org.ziglang.v2.ZigParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Zig'
  psiImplClassSuffix='Impl'
  psiPackage='org.ziglang.v2.psi'
  psiImplPackage='org.ziglang.v2.psi.impl'

  extends('.*Expr')=expr

  tokenTypeClass='org.ziglang.v2.ZigTokenType'
  elementTypeHolderClass='org.ziglang.v2.psi.ZigTypes'
  elementTypeClass='org.ziglang.v2.ZigElementType'
}

Root ::= skip CONTAINER_DOC_COMMENT? ContainerMembers eof

StringLiteralSingle ::= STRING_LITERAL
StringLiteral ::= StringLiteralSingle | LINE_STRING

Identifier ::= IDENTIFIER

// *** Top level ***
ContainerMembers ::= ContainerDeclarations (ContainerField COMMA)* (ContainerField | ContainerDeclarations)

ContainerDeclarations
    ::= TestDecl ContainerDeclarations
     | TopLevelComptime ContainerDeclarations
     | DOC_COMMENT? KEYWORD_PUB? TopLevelDecl ContainerDeclarations
     |
TestDecl ::= DOC_COMMENT? KEYWORD_TEST StringLiteralSingle? Block

TopLevelComptime ::= DOC_COMMENT? KEYWORD_COMPTIME BlockExpr

TopLevelDecl
    ::= (KEYWORD_EXPORT | KEYWORD_EXTERN StringLiteralSingle? | (KEYWORD_INLINE | KEYWORD_NOINLINE))? FnProto (SEMICOLON | Block)
     | (KEYWORD_EXPORT | KEYWORD_EXTERN StringLiteralSingle?)? KEYWORD_THREADLOCAL? VarDecl
     | KEYWORD_USINGNAMESPACE Expr SEMICOLON

FnProto ::= KEYWORD_FN Identifier? LPAREN ParamDeclList RPAREN ByteAlign? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr

VarDecl ::= (KEYWORD_CONST | KEYWORD_VAR) Identifier (COLON TypeExpr)? ByteAlign? LinkSection? (EQUAL Expr)? SEMICOLON

ContainerField ::= DOC_COMMENT? KEYWORD_COMPTIME? Identifier (COLON (KEYWORD_ANYTYPE | TypeExpr) ByteAlign?)? (EQUAL Expr)?

// *** Block Level ***
Statement
    ::= KEYWORD_COMPTIME? VarDecl
     | KEYWORD_COMPTIME BlockExprStatement
     | KEYWORD_NOSUSPEND BlockExprStatement
     | KEYWORD_SUSPEND BlockExprStatement
     | KEYWORD_DEFER BlockExprStatement
     | KEYWORD_ERRDEFER Payload? BlockExprStatement
     | IfStatement
     | LabeledStatement
     | SwitchExpr
     | AssignExpr SEMICOLON

IfStatement
    ::= IfPrefix BlockExpr ( KEYWORD_ELSE Payload? Statement )?
     | IfPrefix AssignExpr ( SEMICOLON | KEYWORD_ELSE Payload? Statement )

LabeledStatement ::= BlockLabel? (Block | LoopStatement)

LoopStatement ::= KEYWORD_INLINE? (ForStatement | WhileStatement)

ForStatement
    ::= ForPrefix BlockExpr ( KEYWORD_ELSE Statement )?
     | ForPrefix AssignExpr ( SEMICOLON | KEYWORD_ELSE Statement )

WhileStatement
    ::= WhilePrefix BlockExpr ( KEYWORD_ELSE Payload? Statement )?
     | WhilePrefix AssignExpr ( SEMICOLON | KEYWORD_ELSE Payload? Statement )

BlockExprStatement
    ::= BlockExpr
     | AssignExpr SEMICOLON

BlockExpr ::= BlockLabel? Block

// *** Expression Level ***
AssignExpr ::= Expr (AssignOp Expr)?

Expr ::= BoolOrExpr

BoolOrExpr ::= BoolAndExpr (KEYWORD_OR BoolAndExpr)*

BoolAndExpr ::= CompareExpr (KEYWORD_AND CompareExpr)*

CompareExpr ::= BitwiseExpr (CompareOp BitwiseExpr)?

BitwiseExpr ::= BitShiftExpr (BitwiseOp BitShiftExpr)*

BitShiftExpr ::= AdditionExpr (BitShiftOp AdditionExpr)*

AdditionExpr ::= MultiplyExpr (AdditionOp MultiplyExpr)*

MultiplyExpr ::= PrefixExpr (MultiplyOp PrefixExpr)*

PrefixExpr ::= PrefixOp* PrimaryExpr

PrimaryExpr
    ::= AsmExpr
     | IfExpr
     | KEYWORD_BREAK BreakLabel? Expr?
     | KEYWORD_COMPTIME Expr
     | KEYWORD_NOSUSPEND Expr
     | KEYWORD_CONTINUE BreakLabel?
     | KEYWORD_RESUME Expr
     | KEYWORD_RETURN Expr?
     | BlockLabel? LoopExpr
     | Block
     | CurlySuffixExpr

IfExpr ::= IfPrefix Expr (KEYWORD_ELSE Payload? Expr)?

Block ::= LBRACE Statement* RBRACE

LoopExpr ::= KEYWORD_INLINE? (ForExpr | WhileExpr)

ForExpr ::= ForPrefix Expr (KEYWORD_ELSE Expr)?

WhileExpr ::= WhilePrefix Expr (KEYWORD_ELSE Payload? Expr)?

CurlySuffixExpr ::= TypeExpr InitList?

InitList
    ::= LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
     | LBRACE Expr (COMMA Expr)* COMMA? RBRACE
     | LBRACE RBRACE

TypeExpr ::= PrefixTypeOp* ErrorUnionExpr

ErrorUnionExpr ::= SuffixExpr (EXCLAMATIONMARK TypeExpr)?

SuffixExpr
    ::= KEYWORD_ASYNC PrimaryTypeExpr SuffixOp* FnCallArguments
     | PrimaryTypeExpr (SuffixOp | FnCallArguments)*

PrimaryTypeExpr
    ::= BUILTINIDENTIFIER FnCallArguments
     | CHAR_LITERAL
     | ContainerDecl
     | DOT Identifier
     | DOT InitList
     | ErrorSetDecl
     | FLOAT
     | FnProto
     | GroupedExpr
     | LabeledTypeExpr
     | Identifier
     | IfTypeExpr
     | INTEGER
     | KEYWORD_COMPTIME TypeExpr
     | KEYWORD_ERROR DOT Identifier
     | KEYWORD_ANYFRAME
     | KEYWORD_UNREACHABLE
     | StringLiteral
     | SwitchExpr

ContainerDecl ::= (KEYWORD_EXTERN | KEYWORD_PACKED)? ContainerDeclAuto

ErrorSetDecl ::= KEYWORD_ERROR LBRACE IdentifierList RBRACE

GroupedExpr ::= LPAREN Expr RPAREN

IfTypeExpr ::= IfPrefix TypeExpr (KEYWORD_ELSE Payload? TypeExpr)?

LabeledTypeExpr
    ::= BlockLabel Block
     | BlockLabel? LoopTypeExpr

LoopTypeExpr ::= KEYWORD_INLINE? (ForTypeExpr | WhileTypeExpr)

ForTypeExpr ::= ForPrefix TypeExpr (KEYWORD_ELSE TypeExpr)?

WhileTypeExpr ::= WhilePrefix TypeExpr (KEYWORD_ELSE Payload? TypeExpr)?

SwitchExpr ::= KEYWORD_SWITCH LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE

// *** Assembly ***
AsmExpr ::= KEYWORD_ASM KEYWORD_VOLATILE? LPAREN Expr AsmOutput? RPAREN

AsmOutput ::= COLON AsmOutputList AsmInput?

AsmOutputItem ::= LBRACKET Identifier RBRACKET StringLiteral LPAREN (MINUSRARROW TypeExpr | Identifier) RPAREN

AsmInput ::= COLON AsmInputList AsmClobbers?

AsmInputItem ::= LBRACKET Identifier RBRACKET StringLiteral LPAREN Expr RPAREN

AsmClobbers ::= COLON StringList

// *** Helper grammar ***
BreakLabel ::= COLON Identifier

BlockLabel ::= Identifier COLON

FieldInit ::= DOT Identifier EQUAL Expr

WhileContinueExpr ::= COLON LPAREN AssignExpr RPAREN

LinkSection ::= KEYWORD_LINKSECTION LPAREN Expr RPAREN

// Fn specific
CallConv ::= KEYWORD_CALLCONV LPAREN Expr RPAREN

ParamDecl
    ::= DOC_COMMENT? (KEYWORD_NOALIAS | KEYWORD_COMPTIME)? (Identifier COLON)? ParamType
     | DOT3

ParamType
    ::= KEYWORD_ANYTYPE
     | TypeExpr

// Control flow prefixes
IfPrefix ::= KEYWORD_IF LPAREN Expr RPAREN PtrPayload?

WhilePrefix ::= KEYWORD_WHILE LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?

ForPrefix ::= KEYWORD_FOR LPAREN Expr RPAREN PtrIndexPayload

// Payloads
Payload ::= PIPE Identifier PIPE

PtrPayload ::= PIPE ASTERISK? Identifier PIPE

PtrIndexPayload ::= PIPE ASTERISK? Identifier (COMMA Identifier)? PIPE


// Switch specific
SwitchProng ::= SwitchCase EQUALRARROW PtrPayload? AssignExpr

SwitchCase
    ::= SwitchItem (COMMA SwitchItem)* COMMA?
     | KEYWORD_ELSE

SwitchItem ::= Expr (DOT3 Expr)?

// Operators
AssignOp
    ::= ASTERISKEQUAL
     | SLASHEQUAL
     | PERCENTEQUAL
     | PLUSEQUAL
     | MINUSEQUAL
     | LARROW2EQUAL
     | RARROW2EQUAL
     | AMPERSANDEQUAL
     | CARETEQUAL
     | PIPEEQUAL
     | ASTERISKPERCENTEQUAL
     | PLUSPERCENTEQUAL
     | MINUSPERCENTEQUAL
     | EQUAL

CompareOp
    ::= EQUALEQUAL
     | EXCLAMATIONMARKEQUAL
     | LARROW
     | RARROW
     | LARROWEQUAL
     | RARROWEQUAL

BitwiseOp
    ::= AMPERSAND
     | CARET
     | PIPE
     | KEYWORD_ORELSE
     | KEYWORD_CATCH Payload?

BitShiftOp
    ::= LARROW2
     | RARROW2

AdditionOp
    ::= PLUS
     | MINUS
     | PLUS2
     | PLUSPERCENT
     | MINUSPERCENT

MultiplyOp
    ::= PIPE2
     | ASTERISK
     | SLASH
     | PERCENT
     | ASTERISK2
     | ASTERISKPERCENT

PrefixOp
    ::= EXCLAMATIONMARK
     | MINUS
     | TILDE
     | MINUSPERCENT
     | AMPERSAND
     | KEYWORD_TRY
     | KEYWORD_AWAIT

PrefixTypeOp
    ::= QUESTIONMARK
     | KEYWORD_ANYFRAME MINUSRARROW
     | SliceTypeStart (ByteAlign | KEYWORD_CONST | KEYWORD_VOLATILE | KEYWORD_ALLOWZERO)*
     | PtrTypeStart (KEYWORD_ALIGN LPAREN Expr (COLON INTEGER COLON INTEGER)? RPAREN | KEYWORD_CONST | KEYWORD_VOLATILE | KEYWORD_ALLOWZERO)*
     | ArrayTypeStart

SuffixOp
    ::= LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET
     | DOT Identifier
     | DOTASTERISK
     | DOTQUESTIONMARK

FnCallArguments ::= LPAREN ExprList RPAREN

// Ptr specific
SliceTypeStart ::= LBRACKET (COLON Expr)? RBRACKET

PtrTypeStart
    ::= ASTERISK
     | ASTERISK2
     | LBRACKET ASTERISK (LETTERC | COLON Expr)? RBRACKET

ArrayTypeStart ::= LBRACKET Expr (COLON Expr)? RBRACKET

// ContainerDecl specific
ContainerDeclAuto ::= ContainerDeclType LBRACE CONTAINER_DOC_COMMENT? ContainerMembers RBRACE

ContainerDeclType
    ::= KEYWORD_STRUCT
     | KEYWORD_OPAQUE
     | KEYWORD_ENUM (LPAREN Expr RPAREN)?
     | KEYWORD_UNION (LPAREN (KEYWORD_ENUM (LPAREN Expr RPAREN)? | Expr) RPAREN)?

// Alignment
ByteAlign ::= KEYWORD_ALIGN LPAREN Expr RPAREN

// Lists
IdentifierList ::= (DOC_COMMENT? Identifier COMMA)* (DOC_COMMENT? Identifier)?

SwitchProngList ::= (SwitchProng COMMA)* SwitchProng?

AsmOutputList ::= (AsmOutputItem COMMA)* AsmOutputItem?

AsmInputList ::= (AsmInputItem COMMA)* AsmInputItem?

StringList ::= (StringLiteral COMMA)* StringLiteral?

ParamDeclList ::= (ParamDecl COMMA)* ParamDecl?

ExprList ::= (Expr COMMA)* Expr?

skip ::= eof | LINE_COMMENT

// *** Tokens ***
//mb_utf8_literal ::=
//       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF
//     | oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF
//     | oxF0      ox90_0xBF ox80_oxBF ox80_oxBF
//     | oxEE_oxEF ox80_oxBF ox80_oxBF
//     | oxED      ox80_ox9F ox80_oxBF
//     | oxE1_oxEC ox80_oxBF ox80_oxBF
//     | oxE0      oxA0_oxBF ox80_oxBF
//     | oxC2_oxDF ox80_oxBF
//
//char_escape ::= "\\x" hex hex
//     | "\\u{" hex+ "}"
//     | "\\" [nr\\t'"]
//
//char_char
//    ::= mb_utf8_literal
//     | char_escape
//     | ascii_char_not_nl_slash_squote
//
//string_char
//    ::= char_escape
//     | [^\\"\n]
//
// CHAR_LITERAL ::= "'" char_char "'"
//
// StringLiteralSingle ::= "\"" string_char* "\""
//
// StringLiteral
//     ::= StringLiteralSingle
//      | (line_string                 skip)+
